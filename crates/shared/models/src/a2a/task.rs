//! A2A Task domain types
//!
//! Core task entities as defined in A2A specification section 6.1.

use super::artifact::Artifact;
use super::message::Message;
use super::task_metadata::TaskMetadata;
use serde::{Deserialize, Serialize};
use systemprompt_identifiers::{ContextId, TaskId};

/// Task entity as defined in A2A spec section 6.1
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct Task {
    /// A unique identifier (e.g. UUID) for the task, generated by the server
    pub id: TaskId,
    /// A server-generated unique identifier for maintaining context across
    /// related tasks
    #[serde(rename = "contextId")]
    pub context_id: ContextId,
    /// The current status of the task, including its state and descriptive
    /// message
    pub status: TaskStatus,
    /// Array of messages exchanged during the task (conversation history)
    pub history: Option<Vec<Message>>,
    /// Collection of artifacts generated by the agent during task execution
    pub artifacts: Option<Vec<Artifact>>,
    /// Optional metadata for extensions
    pub metadata: Option<TaskMetadata>,
    /// Type discriminator - always "task"
    #[serde(rename = "kind")]
    pub kind: String, // Always "task"
}

impl Default for Task {
    fn default() -> Self {
        Self {
            id: TaskId::generate(),
            context_id: ContextId::generate(),
            status: TaskStatus::default(),
            history: None,
            artifacts: None,
            metadata: None,
            kind: "task".to_string(),
        }
    }
}

/// TaskStatus as defined in A2A spec section 6.2
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct TaskStatus {
    /// The current state of the task's lifecycle
    pub state: TaskState,
    /// Optional human-readable message providing status details
    pub message: Option<Message>,
    /// ISO 8601 datetime when this status was recorded (serde serializes to
    /// string)
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
}

impl Default for TaskStatus {
    fn default() -> Self {
        Self {
            state: TaskState::Submitted,
            message: None,
            timestamp: None,
        }
    }
}

/// TaskState lifecycle states as defined in A2A spec section 6.3
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq, Eq)]
pub enum TaskState {
    /// The task has been submitted and is awaiting processing
    #[serde(rename = "pending")]
    Pending,
    /// The task has been submitted and is awaiting execution
    #[serde(rename = "submitted")]
    Submitted,
    /// The agent is actively working on the task
    #[serde(rename = "working")]
    Working,
    /// The task has been successfully completed
    #[serde(rename = "completed")]
    Completed,
    /// The task failed due to an error during execution
    #[serde(rename = "failed")]
    Failed,
    /// The task has been canceled by the user
    #[serde(rename = "canceled")]
    Canceled,
    /// The task has been rejected by the agent
    #[serde(rename = "rejected")]
    Rejected,
    /// The task is paused and waiting for input from the user
    #[serde(rename = "input-required")]
    InputRequired,
    /// The task requires authentication before proceeding
    #[serde(rename = "auth-required")]
    AuthRequired,
    /// The task state is unknown or undefined
    #[serde(rename = "unknown")]
    Unknown,
}

impl std::str::FromStr for TaskState {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pending" => Ok(Self::Pending),
            "submitted" => Ok(Self::Submitted),
            "working" => Ok(Self::Working),
            "completed" => Ok(Self::Completed),
            "failed" => Ok(Self::Failed),
            "canceled" => Ok(Self::Canceled),
            "rejected" => Ok(Self::Rejected),
            "input-required" => Ok(Self::InputRequired),
            "auth-required" => Ok(Self::AuthRequired),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Invalid task state: {s}")),
        }
    }
}
