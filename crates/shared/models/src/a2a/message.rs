//! A2A Message domain types
//!
//! Message and communication entities as defined in A2A specification.

use serde::{Deserialize, Serialize};
use systemprompt_identifiers::{ContextId, MessageId, TaskId};

/// Message entity as defined in A2A spec
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct Message {
    /// Identifies sender: "user" for client, "agent" for service
    pub role: String, // "user" | "agent"
    /// Array of content parts that form the message body
    pub parts: Vec<Part>,
    /// Unique identifier for the message (typically UUID), generated by sender
    #[serde(rename = "messageId")]
    pub id: MessageId,
    /// ID of the task this message is part of (omitted for first message of new
    /// task)
    #[serde(rename = "taskId")]
    pub task_id: Option<TaskId>,
    /// Context ID for this message - REQUIRED for all message operations
    #[serde(rename = "contextId")]
    pub context_id: ContextId,
    /// Type discriminator - always "message"
    #[serde(rename = "kind")]
    pub kind: String, // Always "message"
    /// Optional metadata for extensions (key is extension-specific identifier)
    pub metadata: Option<serde_json::Value>,
    /// URIs of extensions relevant to this message
    pub extensions: Option<Vec<String>>,
    /// List of other task IDs this message references for context
    #[serde(rename = "referenceTaskIds")]
    pub reference_task_ids: Option<Vec<TaskId>>,
}

/// Message role as defined in A2A spec
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    /// Message from the client/user
    User,
    /// Message from the agent/service
    Agent,
}

/// Content part enum for message parts
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
#[serde(tag = "kind")]
pub enum Part {
    #[serde(rename = "text")]
    Text(TextPart),
    #[serde(rename = "data")]
    Data(DataPart),
    #[serde(rename = "file")]
    File(FilePart),
}

/// Text content part
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct TextPart {
    pub text: String,
}

/// Structured data content part
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct DataPart {
    pub data: serde_json::Map<String, serde_json::Value>,
}

/// File content part
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct FilePart {
    pub file: FileWithBytes,
}

/// File with embedded bytes
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct FileWithBytes {
    pub name: Option<String>,
    #[serde(rename = "mimeType")]
    pub mime_type: Option<String>,
    pub bytes: String, // base64-encoded
}
