use super::AuthorizeQuery;
use crate::repository::OAuthRepository;
use anyhow::Result;

pub async fn validate_authorize_request(
    params: &AuthorizeQuery,
    repo: &OAuthRepository,
) -> Result<String> {
    if params.response_type != "code" {
        return Err(anyhow::anyhow!(
            "Unsupported response_type. Only 'code' is supported"
        ));
    }

    let client = repo
        .find_client_by_id(&params.client_id)
        .await?
        .ok_or_else(|| anyhow::anyhow!("Invalid client_id"))?;

    if let Some(redirect_uri) = &params.redirect_uri {
        let is_valid = client.redirect_uris.contains(redirect_uri);

        if !is_valid {
            return Err(anyhow::anyhow!(
                "redirect_uri '{}' not registered for client '{}'",
                redirect_uri,
                params.client_id
            ));
        }
    }

    let scope = if let Some(scope_param) = params.scope.as_deref() {
        scope_param.to_string()
    } else {
        if client.scopes.is_empty() {
            return Err(anyhow::anyhow!(
                "Client has no registered scopes and none provided in request"
            ));
        }
        client.scopes.join(" ")
    };

    let requested_scopes = OAuthRepository::parse_scopes(&scope);

    let valid_scopes = repo
        .validate_scopes(&requested_scopes)
        .await
        .map_err(|e| anyhow::anyhow!("Invalid scopes requested: {e}"))?;

    for requested_scope in &valid_scopes {
        if !client.scopes.contains(requested_scope) {
            return Err(anyhow::anyhow!(
                "Scope '{}' not allowed for client '{}'",
                requested_scope,
                params.client_id
            ));
        }
    }

    Ok(scope)
}

pub fn validate_oauth_parameters(params: &AuthorizeQuery) -> Result<(), String> {
    if params.response_type != "code" {
        return Err(format!(
            "Unsupported response_type '{}'. Only 'code' is supported.",
            params.response_type
        ));
    }

    if let Some(response_mode) = &params.response_mode {
        if response_mode != "query" {
            return Err(format!(
                "Unsupported response_mode '{response_mode}'. Only 'query' mode is supported."
            ));
        }
    }

    if let Some(code_challenge) = &params.code_challenge {
        if code_challenge.len() < 43 {
            return Err(
                "code_challenge too short. Must be at least 43 characters for security."
                    .to_string(),
            );
        }
        if code_challenge.len() > 128 {
            return Err("code_challenge too long. Must be at most 128 characters.".to_string());
        }

        let is_valid_base64url = code_challenge
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_');

        if !is_valid_base64url {
            return Err(
                "code_challenge must be base64url encoded (A-Z, a-z, 0-9, -, _)".to_string(),
            );
        }

        if is_low_entropy_challenge(code_challenge) {
            return Err(
                "code_challenge appears to have insufficient entropy for security".to_string(),
            );
        }

        let method = params.code_challenge_method.as_deref().ok_or_else(|| {
            "code_challenge_method is required when code_challenge is provided".to_string()
        })?;

        match method {
            "S256" => {},
            "plain" => {
                return Err(
                    "PKCE method 'plain' is not allowed. Use 'S256' for security.".to_string(),
                );
            },
            _ => {
                return Err(format!(
                    "Unsupported code_challenge_method '{method}'. Only 'S256' is allowed."
                ));
            },
        }
    }

    if let Some(display) = &params.display {
        match display.as_str() {
            "page" | "popup" | "touch" | "wap" => {},
            _ => {
                return Err(format!(
                    "Unsupported display value '{display}'. Supported values: page, popup, touch, \
                     wap."
                ));
            },
        }
    }

    if let Some(prompt) = &params.prompt {
        for prompt_value in prompt.split_whitespace() {
            match prompt_value {
                "none" | "login" | "consent" | "select_account" => {},
                _ => {
                    return Err(format!(
                        "Unsupported prompt value '{prompt_value}'. Supported values: none, \
                         login, consent, select_account."
                    ));
                },
            }
        }
    }

    if let Some(max_age) = params.max_age {
        if max_age < 0 {
            return Err("max_age must be a non-negative integer".to_string());
        }
    }

    Ok(())
}

/// Validates that a PKCE code_challenge has sufficient entropy for security.
///
/// Per RFC 7636, the code_verifier (and thus the challenge) should have at least
/// 256 bits of entropy. This function uses heuristics to detect obviously weak
/// challenges that would fail to provide adequate security.
///
/// Checks performed:
/// - All same character (e.g., "aaaa...")
/// - Simple repeating patterns (e.g., "abcabcabc...")
/// - Long sequential runs (e.g., "abcdefgh...")
/// - Low character diversity (unique chars / total length)
fn is_low_entropy_challenge(challenge: &str) -> bool {
    // Check 1: All same character
    let Some(first_char) = challenge.chars().next() else {
        return true;
    };
    if challenge.chars().all(|c| c == first_char) {
        return true;
    }

    // Check 2: Simple repeating patterns (2-4 char patterns repeated)
    for pattern_length in 2..=4 {
        if challenge.len() >= pattern_length * 3 {
            let pattern = &challenge[..pattern_length];
            let repetitions = challenge.len() / pattern_length;
            if repetitions >= 3 {
                let repeated = pattern.repeat(repetitions);
                // Check if the challenge starts with this repeated pattern
                if challenge.starts_with(&repeated) {
                    return true;
                }
            }
        }
    }

    // Check 3: Sequential character runs (detect "abcdef...", "123456...", etc.)
    // Reject if 6 or more sequential characters are found (stricter than before)
    let chars: Vec<char> = challenge.chars().collect();
    if chars.len() >= 6 {
        let mut sequential_count = 1;
        let mut reverse_sequential_count = 1;

        for i in 1..chars.len() {
            // Check ascending sequence (a, b, c, d, ...)
            if let (Some(prev), Some(curr)) = (chars[i - 1].to_digit(36), chars[i].to_digit(36)) {
                if curr == prev.wrapping_add(1) {
                    sequential_count += 1;
                    if sequential_count >= 6 {
                        return true;
                    }
                } else {
                    sequential_count = 1;
                }

                // Also check descending sequence (z, y, x, w, ...)
                if prev == curr.wrapping_add(1) {
                    reverse_sequential_count += 1;
                    if reverse_sequential_count >= 6 {
                        return true;
                    }
                } else {
                    reverse_sequential_count = 1;
                }
            }
        }
    }

    // Check 4: Character diversity (entropy approximation)
    // For a 43+ character challenge, we expect good distribution.
    // A stricter threshold of 0.5 means at least half the characters should be unique.
    // For base64url (64 possible chars), a random 43-char string would have ~0.93 ratio.
    let unique_chars: std::collections::HashSet<char> = challenge.chars().collect();
    let entropy_ratio = unique_chars.len() as f64 / challenge.len() as f64;

    // Use 0.5 as threshold - requires at least 50% unique characters
    // This catches challenges like "aAbBaAbBaAbB..." while allowing legitimate random strings
    if entropy_ratio < 0.5 {
        return true;
    }

    // Check 5: Minimum unique character count
    // For a 43-char challenge, we should have at least 20 unique characters
    // (roughly half, accounting for some repetition in random strings)
    let min_unique_for_length = challenge.len() / 2;
    if unique_chars.len() < min_unique_for_length.min(20) {
        return true;
    }

    false
}
