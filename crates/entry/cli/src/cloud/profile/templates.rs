use anyhow::{Context, Result};
use std::path::Path;
use systemprompt_core_logging::CliService;
use systemprompt_models::Profile;

pub use crate::common::profile::{generate_display_name, generate_jwt_secret};

pub fn save_profile(profile: &Profile, profile_path: &Path) -> Result<()> {
    let header = format!(
        "# SystemPrompt Profile: {}\n# Generated by 'systemprompt cloud profile create'",
        profile.display_name
    );

    crate::common::profile::save_profile_yaml(profile, profile_path, Some(&header))
}

pub fn save_dockerfile(path: &Path, profile_name: &str) -> Result<()> {
    let content = format!(
        r#"# SystemPrompt Application Dockerfile
# Built by: systemprompt cloud profile create
# Used by: systemprompt cloud deploy

FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    curl \
    libssl3 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

RUN useradd -m -u 1000 app
WORKDIR /app

RUN mkdir -p /app/bin /app/bin/mcp /app/storage/images/blog /app/storage/images/social /app/storage/images/logos /app/storage/images/generated /app/storage/files/audio /app/storage/files/video /app/storage/files/documents /app/storage/files/uploads

# Copy pre-built binaries
COPY target/release/systemprompt /app/bin/

# Copy MCP server binaries (if they exist)
COPY target/release/systemprompt-* /app/bin/mcp/ 2>/dev/null || true

# Copy web assets
COPY core/web/dist /app/web/dist

# Copy storage assets (images, etc.)
COPY storage /app/storage

# Copy services configuration
COPY services /app/services

# Copy profiles
COPY .systemprompt/profiles /app/services/profiles

RUN chmod +x /app/bin/* && chown -R app:app /app

USER app
EXPOSE 8080

# Environment: secrets loaded from fly secrets, profile from bundled file
ENV HOST=0.0.0.0 \
    PORT=8080 \
    RUST_LOG=info \
    PATH="/app/bin:/app/bin/mcp:$PATH" \
    SYSTEMPROMPT_PROFILE=/app/services/profiles/{profile_name}/profile.yaml \
    SYSTEMPROMPT_SERVICES_PATH=/app/services \
    WEB_DIR=/app/web

HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:8080/api/v1/health || exit 1

CMD ["/app/bin/systemprompt", "services", "serve", "--foreground"]
"#,
        profile_name = profile_name
    );

    std::fs::write(path, content).with_context(|| format!("Failed to write {}", path.display()))?;

    Ok(())
}

pub fn save_entrypoint(path: &Path) -> Result<()> {
    let content = r#"#!/bin/sh
set -e

echo "Running database migrations..."
/app/bin/systemprompt services db migrate

echo "Starting services..."
exec /app/bin/systemprompt services serve --foreground
"#;

    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    std::fs::write(path, content).with_context(|| format!("Failed to write {}", path.display()))?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = std::fs::Permissions::from_mode(0o755);
        std::fs::set_permissions(path, permissions)
            .with_context(|| format!("Failed to set permissions on {}", path.display()))?;
    }

    Ok(())
}

pub fn save_dockerignore(path: &Path) -> Result<()> {
    let content = r".git
.gitignore
.gitmodules
target/debug
.cargo
.systemprompt/credentials.json
.systemprompt/tenants.json
.systemprompt/**/secrets.json
.systemprompt/docker
.systemprompt/storage
.env*
backup
docs
instructions
*.md
core/web/node_modules
.vscode
.idea
logs
*.log
plan
";

    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    std::fs::write(path, content).with_context(|| format!("Failed to write {}", path.display()))?;

    Ok(())
}

pub struct DatabaseUrls<'a> {
    pub external: &'a str,
    pub internal: Option<&'a str>,
}

pub fn save_secrets(
    db_urls: &DatabaseUrls<'_>,
    api_keys: &super::api_keys::ApiKeys,
    secrets_path: &Path,
) -> Result<()> {
    use serde_json::json;

    if let Some(parent) = secrets_path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    let mut secrets = json!({
        "jwt_secret": generate_jwt_secret(),
        "database_url": db_urls.external,
        "gemini": api_keys.gemini,
        "anthropic": api_keys.anthropic,
        "openai": api_keys.openai
    });

    if let Some(internal) = db_urls.internal {
        secrets["internal_database_url"] = json!(internal);
    }

    let content = serde_json::to_string_pretty(&secrets).context("Failed to serialize secrets")?;

    std::fs::write(secrets_path, content)
        .with_context(|| format!("Failed to write {}", secrets_path.display()))?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = std::fs::Permissions::from_mode(0o600);
        std::fs::set_permissions(secrets_path, permissions)
            .with_context(|| format!("Failed to set permissions on {}", secrets_path.display()))?;
    }

    Ok(())
}


pub fn get_services_path() -> Result<String> {
    if let Ok(path) = std::env::var("SYSTEMPROMPT_SERVICES_PATH") {
        return Ok(path);
    }

    let cwd = std::env::current_dir().context("Failed to get current directory")?;
    let services_path = cwd.join("services");

    Ok(services_path.to_string_lossy().to_string())
}

pub async fn validate_connection(db_url: &str) -> bool {
    use tokio::time::{timeout, Duration};

    let result = timeout(Duration::from_secs(5), async {
        sqlx::postgres::PgPoolOptions::new()
            .max_connections(1)
            .connect(db_url)
            .await
    })
    .await;

    matches!(result, Ok(Ok(_)))
}

pub async fn run_migrations_cmd(profile_path: &Path) -> Result<()> {
    use std::process::Command;

    CliService::info("Running database migrations...");

    let current_exe = std::env::current_exe().context("Failed to get executable path")?;
    let profile_path_str = profile_path.to_string_lossy();

    let output = Command::new(&current_exe)
        .args(["services", "db", "migrate"])
        .env("SYSTEMPROMPT_PROFILE", profile_path_str.as_ref())
        .output()
        .context("Failed to run migrations")?;

    if output.status.success() {
        CliService::success("Migrations completed");
        return Ok(());
    }

    let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
    if !stderr.is_empty() {
        CliService::warning(&format!("Migration warning: {}", stderr));
    }

    Ok(())
}
