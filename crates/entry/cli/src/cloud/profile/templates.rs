use anyhow::{Context, Result};
use std::path::Path;
use systemprompt_core_logging::CliService;
use systemprompt_models::Profile;

pub fn save_profile(profile: &Profile, profile_path: &Path) -> Result<()> {
    if let Some(parent) = profile_path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    let content = serde_yaml::to_string(profile).context("Failed to serialize profile")?;

    let header = format!(
        "# SystemPrompt Profile: {}\n# Generated by 'systemprompt cloud profile create'\n\n",
        profile.display_name
    );

    std::fs::write(profile_path, format!("{}{}", header, content))
        .with_context(|| format!("Failed to write {}", profile_path.display()))?;

    Ok(())
}

pub fn save_dockerfile(path: &Path, profile_name: &str) -> Result<()> {
    let content = format!(
        r#"# SystemPrompt Application Dockerfile
# Built by: systemprompt cloud profile create
# Used by: systemprompt cloud deploy

FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    curl \
    libssl3 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

RUN useradd -m -u 1000 app
WORKDIR /app

RUN mkdir -p /app/bin /app/bin/mcp /app/storage

# Copy pre-built binaries
COPY target/release/systemprompt /app/bin/

# Copy MCP server binaries (if they exist)
COPY target/release/systemprompt-* /app/bin/mcp/ 2>/dev/null || true

# Copy web assets
COPY core/web/dist /app/web

# Copy services configuration
COPY services /app/services

# Copy profiles
COPY .systemprompt/profiles /app/services/profiles

RUN chmod +x /app/bin/* && chown -R app:app /app

USER app
EXPOSE 8080

# Environment: secrets loaded from fly secrets, profile from bundled file
ENV HOST=0.0.0.0 \
    PORT=8080 \
    RUST_LOG=info \
    PATH="/app/bin:/app/bin/mcp:$PATH" \
    SYSTEMPROMPT_PROFILE=/app/services/profiles/{profile_name}/profile.yaml \
    SYSTEMPROMPT_SERVICES_PATH=/app/services \
    WEB_DIR=/app/web

HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:8080/api/v1/health || exit 1

CMD ["/app/bin/systemprompt", "services", "serve", "--foreground"]
"#,
        profile_name = profile_name
    );

    std::fs::write(path, content).with_context(|| format!("Failed to write {}", path.display()))?;

    Ok(())
}

pub fn save_secrets(
    database_url: &str,
    api_keys: &super::api_keys::ApiKeys,
    secrets_path: &Path,
) -> Result<()> {
    use serde_json::json;

    if let Some(parent) = secrets_path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    let secrets = json!({
        "jwt_secret": generate_jwt_secret(),
        "database_url": database_url,
        "gemini": api_keys.gemini,
        "anthropic": api_keys.anthropic,
        "openai": api_keys.openai
    });

    let content = serde_json::to_string_pretty(&secrets).context("Failed to serialize secrets")?;

    std::fs::write(secrets_path, content)
        .with_context(|| format!("Failed to write {}", secrets_path.display()))?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = std::fs::Permissions::from_mode(0o600);
        std::fs::set_permissions(secrets_path, permissions)
            .with_context(|| format!("Failed to set permissions on {}", secrets_path.display()))?;
    }

    Ok(())
}

fn generate_jwt_secret() -> String {
    use rand::distributions::Alphanumeric;
    use rand::{thread_rng, Rng};

    let mut rng = thread_rng();
    (0..64)
        .map(|_| rng.sample(Alphanumeric))
        .map(char::from)
        .collect()
}

pub fn generate_display_name(name: &str) -> String {
    match name.to_lowercase().as_str() {
        "dev" | "development" => "Development".to_string(),
        "prod" | "production" => "Production".to_string(),
        "staging" | "stage" => "Staging".to_string(),
        "test" | "testing" => "Test".to_string(),
        "local" => "Local".to_string(),
        "cloud" => "Cloud".to_string(),
        _ => {
            let mut chars = name.chars();
            match chars.next() {
                None => name.to_string(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        },
    }
}

pub fn get_services_path() -> Result<String> {
    if let Ok(path) = std::env::var("SYSTEMPROMPT_SERVICES_PATH") {
        return Ok(path);
    }

    let cwd = std::env::current_dir().context("Failed to get current directory")?;
    let services_path = cwd.join("services");

    Ok(services_path.to_string_lossy().to_string())
}

pub async fn validate_connection(db_url: &str) -> bool {
    use tokio::time::{timeout, Duration};

    let result = timeout(Duration::from_secs(5), async {
        sqlx::postgres::PgPoolOptions::new()
            .max_connections(1)
            .connect(db_url)
            .await
    })
    .await;

    match result {
        Ok(Ok(_pool)) => true,
        _ => false,
    }
}

pub async fn run_migrations_cmd(profile_path: &Path) -> Result<()> {
    use std::process::Command;

    CliService::info("Running database migrations...");

    let current_exe = std::env::current_exe().context("Failed to get executable path")?;
    let profile_path_str = profile_path.to_string_lossy();

    let output = Command::new(&current_exe)
        .args(["services", "db", "migrate"])
        .env("SYSTEMPROMPT_PROFILE", profile_path_str.as_ref())
        .output()
        .context("Failed to run migrations")?;

    if output.status.success() {
        CliService::success("Migrations completed");
        return Ok(());
    }

    let stderr = String::from_utf8_lossy(&output.stderr).trim().to_string();
    if !stderr.is_empty() {
        CliService::warning(&format!("Migration warning: {}", stderr));
    }

    Ok(())
}
