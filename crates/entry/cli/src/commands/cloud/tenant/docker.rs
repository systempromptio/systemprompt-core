use anyhow::{anyhow, bail, Context, Result};
use std::net::TcpListener;
use std::path::Path;
use std::process::Command;
use std::time::Duration;
use systemprompt_logging::CliService;

pub fn nanoid() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis())
        .unwrap_or(0);
    format!("{:x}", timestamp)
}

pub fn generate_postgres_compose(
    tenant_name: &str,
    user: &str,
    password: &str,
    db: &str,
    port: u16,
) -> String {
    format!(
        r#"# systemprompt.io PostgreSQL - Tenant: {tenant_name}
# Generated by: systemprompt cloud tenant create
# Manage: docker compose -f .systemprompt/docker/{tenant_name}.yaml up/down

services:
  postgres:
    image: postgres:17-alpine
    container_name: systemprompt-postgres-{tenant_name}
    restart: unless-stopped
    environment:
      POSTGRES_USER: {user}
      POSTGRES_PASSWORD: {password}
      POSTGRES_DB: {db}
    ports:
      - "{port}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {user} -d {db}"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    name: systemprompt-postgres-{tenant_name}-data
"#,
        tenant_name = tenant_name,
        user = user,
        password = password,
        db = db,
        port = port
    )
}

pub fn is_port_in_use(port: u16) -> bool {
    TcpListener::bind(format!("127.0.0.1:{}", port)).is_err()
}

pub fn stop_container_on_port(port: u16) -> Result<()> {
    let output = Command::new("docker")
        .args(["ps", "--filter", &format!("publish={}", port), "-q"])
        .output()
        .context("Failed to query docker containers")?;

    let container_id = String::from_utf8_lossy(&output.stdout).trim().to_string();

    if !container_id.is_empty() {
        let display_id = &container_id[..12.min(container_id.len())];
        CliService::info(&format!("Stopping container {}...", display_id));
        Command::new("docker")
            .args(["stop", &container_id])
            .status()
            .context("Failed to stop container")?;
        Command::new("docker")
            .args(["rm", &container_id])
            .status()
            .context("Failed to remove container")?;
        CliService::success("Container stopped and removed");
    }

    std::thread::sleep(Duration::from_millis(500));

    Ok(())
}

pub async fn wait_for_postgres_healthy(compose_path: &Path, timeout_secs: u64) -> Result<()> {
    let start = std::time::Instant::now();
    let compose_path_str = compose_path
        .to_str()
        .ok_or_else(|| anyhow!("Invalid compose path"))?;

    loop {
        let output = Command::new("docker")
            .args([
                "compose",
                "-f",
                compose_path_str,
                "ps",
                "--format",
                "{{.Health}}",
            ])
            .output()
            .context("Failed to check container health")?;

        let health = String::from_utf8_lossy(&output.stdout).trim().to_string();

        if health.contains("healthy") {
            return Ok(());
        }

        if start.elapsed().as_secs() > timeout_secs {
            bail!(
                "Timeout waiting for PostgreSQL to become healthy.\nCheck logs with: docker \
                 compose -f {} logs",
                compose_path.display()
            );
        }

        tokio::time::sleep(Duration::from_secs(2)).await;
    }
}
